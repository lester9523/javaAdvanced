# javaAdvanced

#### 介绍
homework


week02 homework about gc

GC算法的背景
产生原因:内存资源的有限性

一般的GC算法:

引用计数法
标记清除法
标记复制法
标记压缩法

GC发生的地方是在堆空间的Young区、Old区，所以针对不同的区域特性进行不同的策略算法进行管理。

不同的JDK版本也支持不同的GC算法，可以根据实际生产配置(CPU、内存大小)进行不同GC算法的使用，主要包括几种:

串行GC

并行GC

CMS GC

G1 GC

1.
单核单CPU,内存较小的环境，可以使用串行GC策略，串行GC在Yong区主要使用的是复制标记法，将Eden区和S1的存活对象复制到S0区，然后进行内存删除。对Old区的对象主要使用的是标记压缩算法，将失去引用的Old对象进行标记后清除，将内存空间空闲的部分压缩，使fullGC后的Old区空间连续整齐，便于后续管理。需要注意的是，每次YoungGC、FullGC都会进行STW操作。
2.
并行GC是基于CPU多核的情况下，对串行GC进行的升级，即所有的操作都可以运用多个线程去操作，相比串行GC大大提高的效率，增加了吞吐量，各个区域使用的算法与串行GC一致,但是每次Gc操作时也都会进行STW操作，如果遇到比较长时间的GC操作，会使系统性能大大下降。
3.
CMSGC也是基于CPU多核情况下的策略升级，Young区仍然采用复制标记算法，但是在Old区贼是采用了标记清除算法，并不进行空间的压缩，而是使用一种空闲队列的策略去处理未被压缩处理的内存空间，其目的也是为了防止比较耗时的FullGC操作影响整个系统的性能，而且相比于并行GC，CMSGC采用的是并行策略，即只有部分的线程会进行GC的局部操作，其他线程仍然可以正常工作，大大提高了系统的吞吐量和性能。
4.G1GC是对CMSGC的策略升级，并且对堆内存空间的划分上一反常态，将内存分成了若干个(默认2048)region区域进行碎片化管理，各个区域可能也在随时发生改变，某个为Yong区的region，可能会变为old区，而且在回收策略上，是对各个region实际的内存使用情况和垃圾数目的情况进行GC回收，每次只处理排名靠前的region区域，大大提高了系统的性能。由于每个region的内存不会特别大，所以也可能出现内存不够的情况，可以根据实际情况进行调整，比如扩大屋里内存空间，或者提高堆内存所占空间，使每个region的内存等比例增加。

